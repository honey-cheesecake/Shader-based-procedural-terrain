#pragma kernel CSMain

RWTexture2D<float> Result;

int width, height;
float2 offset;
float scale;
float power;
bool ridge;

float noise(float3 x);

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float3 samplePoint = float3((float) id.x / width, (float)id.y/height, 1) * scale;
	samplePoint += float3(offset, 0);
	//float res = noise(samplePoint + offset3);

	float res = noise(samplePoint) + 0.5 * noise(2 * samplePoint);
	if (!ridge)
	{
		res += 0.25 *  noise(4* samplePoint) +
			0.125 *noise(8* samplePoint );
		res /= (1 + 0.5 + 0.25 + 0.125);
	}
	else
	{
		res /= (1 + 0.5);
	}

	if (ridge)
	{
		res = 2 * abs(res - 0.5f);
	}
	res = 1 - res;


	if (res < 0)
	{
		res == 0;
	}
	else if (res > 1)
	{
		res == 1;
	}

	res = pow(res, power);

	Result[id.xy] = res;
}


//https://thebookofshaders.com/11/
// https://www.reddit.com/r/proceduralgeneration/comments/i86ss9/compute_shader_noise_for_landscape_generation/
// https://gpfault.net/posts/perlin-noise.txt.html

// https://stackoverflow.com/questions/15628039/simplex-noise-shader
float hash(float n)
{
	return frac(sin(n)*43758.5453);
}

float noise(float3 x)
{
	// The noise function returns a value in the range -1.0f -> 1.0f

	float3 p = floor(x);
	float3 f = frac(x);

	f = f * f*(3.0 - 2.0*f);
	float n = p.x + p.y*57.0 + 113.0*p.z;

	float res = lerp(lerp(lerp(hash(n + 0.0), hash(n + 1.0), f.x),
		lerp(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
		lerp(lerp(hash(n + 113.0), hash(n + 114.0), f.x),
			lerp(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);

	return res; 
}